<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>TickMaster Tool - v2</title>
        <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
        <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: #f5f5f5;
                padding: 20px;
                color: #333;
            }

            .bot-general {
                max-width: 1200px;
                margin: 0 auto;
                background: white;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            }

            .st-header {
                border-bottom: 2px solid #007bff;
                padding-bottom: 15px;
                margin-bottom: 20px;
            }

            .st-title {
                font-size: 28px;
                color: #007bff;
                margin-bottom: 10px;
            }

            .vol-price {
                font-size: 16px;
                color: #666;
            }

            .vol-price strong {
                color: #007bff;
                font-size: 18px;
            }

            .bot-controlz-wrapper {
                margin-bottom: 20px;
            }

            .bot-controlz {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin-bottom: 20px;
            }

            .bot-controlz label {
                display: flex;
                flex-direction: column;
                gap: 5px;
                font-weight: 500;
            }

            .bot-controlz select,
            .bot-controlz input[type='number'] {
                padding: 8px 12px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 14px;
            }

            .martingale-section {
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .toggle-label {
                position: relative;
                display: inline-block;
                width: 50px;
                height: 24px;
            }

            .toggle-label input {
                opacity: 0;
                width: 0;
                height: 0;
            }

            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #ccc;
                transition: 0.4s;
                border-radius: 24px;
            }

            .slider:before {
                position: absolute;
                content: '';
                height: 18px;
                width: 18px;
                left: 3px;
                bottom: 3px;
                background-color: white;
                transition: 0.4s;
                border-radius: 50%;
            }

            input:checked + .slider {
                background-color: #28a745;
            }

            input:checked + .slider:before {
                transform: translateX(26px);
            }

            .toggle-text {
                font-weight: 500;
            }

            .martingale-input {
                margin-top: 10px;
            }

            .signal-display-zone {
                background: #f8f9fa;
                border: 2px dashed #ddd;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
                margin-bottom: 20px;
                min-height: 100px;
            }

            .signal-display-zone.signal-found {
                border-color: #28a745;
                background: #d4edda;
            }

            .signal-found-header {
                color: #28a745;
                font-size: 24px;
                margin-bottom: 10px;
            }

            .blink-text {
                font-size: 18px;
                font-weight: bold;
                color: #007bff;
                animation: blink 1s infinite;
            }

            @keyframes blink {
                0%,
                50% {
                    opacity: 1;
                }
                51%,
                100% {
                    opacity: 0.5;
                }
            }

            .action-buttons-container {
                margin-bottom: 20px;
            }

            .scan-btnn {
                padding: 12px 24px;
                font-size: 16px;
                font-weight: bold;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                margin-right: 10px;
                transition: all 0.3s;
            }

            .scan-btnn.scanning {
                background: #dc3545;
                color: white;
            }

            .scan-btnn.stopped {
                background: #28a745;
                color: white;
            }

            .scan-btnn:hover {
                opacity: 0.9;
                transform: translateY(-2px);
            }

            .user-buttons {
                display: flex;
                gap: 10px;
                margin-bottom: 20px;
            }

            .my-run-button,
            .my-stop-button {
                padding: 12px 24px;
                font-size: 16px;
                font-weight: bold;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 8px;
                transition: all 0.3s;
            }

            .my-run-button {
                background: #17a2b8;
                color: white;
            }

            .my-stop-button {
                background: #dc3545;
                color: white;
            }

            .data-reset-btn {
                padding: 12px 24px;
                font-size: 16px;
                border: 1px solid #ddd;
                background: white;
                border-radius: 6px;
                cursor: pointer;
            }

            .main-table-contents {
                margin-bottom: 20px;
            }

            .main-table-contents h3 {
                margin-bottom: 15px;
                color: #007bff;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                background: white;
            }

            thead {
                background: #007bff;
                color: white;
            }

            th,
            td {
                padding: 12px;
                text-align: left;
                border-bottom: 1px solid #ddd;
            }

            .zero-transactions {
                text-align: center;
                padding: 40px;
                color: #999;
            }

            .profit-win {
                color: #28a745;
                font-weight: bold;
            }

            .profit-loss {
                color: #dc3545;
                font-weight: bold;
            }

            .trades-summary {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin-bottom: 20px;
            }

            .summary-item {
                background: #f8f9fa;
                padding: 15px;
                border-radius: 6px;
                text-align: center;
            }

            .summary-item h3 {
                font-size: 14px;
                color: #666;
                margin-bottom: 8px;
            }

            .summary-item p {
                font-size: 24px;
                font-weight: bold;
                color: #333;
            }

            .display.profit-won {
                color: #28a745;
            }

            .display.profit-lost {
                color: #dc3545;
            }

            .stats-container {
                margin-top: 30px;
                padding-top: 20px;
                border-top: 2px solid #ddd;
            }

            .stats-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                cursor: pointer;
            }

            .section-heading {
                font-size: 18px;
                font-weight: bold;
                color: #007bff;
                margin-bottom: 15px;
            }

            .stats-gridd {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 10px;
                margin-bottom: 20px;
            }

            .stat-item {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                text-align: center;
            }

            .stat-item strong {
                display: block;
                font-size: 14px;
                margin-bottom: 5px;
            }

            .stat-item span {
                font-size: 20px;
                font-weight: bold;
            }

            .ticks-list {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-bottom: 20px;
                padding: 15px;
                background: #f8f9fa;
                border-radius: 8px;
            }

            .tick-item {
                background: #007bff;
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 14px;
            }

            .tick-item.latest {
                background: #28a745;
                transform: scale(1.1);
            }

            .loadingg {
                display: flex;
                justify-content: center;
                gap: 5px;
                margin-bottom: 10px;
            }

            .loadingg span {
                width: 10px;
                height: 10px;
                background: #007bff;
                border-radius: 50%;
                animation: bounce 1.4s infinite ease-in-out;
            }

            .loadingg span:nth-child(1) {
                animation-delay: -0.32s;
            }
            .loadingg span:nth-child(2) {
                animation-delay: -0.16s;
            }
            .loadingg span:nth-child(3) {
                animation-delay: 0s;
            }
            .loadingg span:nth-child(4) {
                animation-delay: 0.16s;
            }
            .loadingg span:nth-child(5) {
                animation-delay: 0.32s;
            }

            @keyframes bounce {
                0%,
                80%,
                100% {
                    transform: scale(0);
                }
                40% {
                    transform: scale(1);
                }
            }

            .its-running {
                color: #28a745;
                font-weight: bold;
                text-align: center;
                margin-bottom: 15px;
            }

            .countdown-msg {
                text-align: center;
                color: #dc3545;
                font-weight: bold;
                margin-bottom: 15px;
            }
        </style>
    </head>
    <body>
        <div id="root">
            <div style="padding: 20px; text-align: center">
                <p>Loading TickMaster Tool...</p>
                <p style="color: #666; font-size: 14px">
                    If this message doesn't disappear, check the browser console (F12) for errors.
                </p>
            </div>
        </div>

        <script type="text/babel">
            // Verify React is loaded
            if (typeof React === 'undefined') {
                document.getElementById('root').innerHTML =
                    '<div style="padding: 20px; color: red;">Error: React library failed to load. Please refresh the page.</div>';
            }

            const { useState, useEffect, useRef } = React;

            function TickMasterTool() {
                // State
                const [volatility, setVolatility] = useState('1HZ25V');
                const [contractType, setContractType] = useState('UNDER');
                const [prediction, setPrediction] = useState('7');
                const [stake, setStake] = useState(1);
                const [duration, setDuration] = useState(1);
                const [targetProfit, setTargetProfit] = useState(50);
                const [stopLoss, setStopLoss] = useState(100);
                const [useMartingale, setUseMartingale] = useState(true);
                const [martingale, setMartingale] = useState(2.0);
                const [tickCount, setTickCount] = useState(100);
                const [price, setPrice] = useState(null);
                const [scanning, setScanning] = useState(false);
                const [running, setRunning] = useState(false);
                const [signal, setSignal] = useState('');
                const [hasSignal, setHasSignal] = useState(false);
                const [countdown, setCountdown] = useState(0);
                const [transactions, setTransactions] = useState([]);
                const [runs, setRuns] = useState(0);
                const [won, setWon] = useState(0);
                const [lost, setLost] = useState(0);
                const [totalProfit, setTotalProfit] = useState(0);
                const [percentages, setPercentages] = useState({});
                const [lastDigits, setLastDigits] = useState([]);
                const [loading, setLoading] = useState(false);
                const [mlpModel, setMlpModel] = useState(null);
                const [gruModel, setGruModel] = useState(null);
                const [mlpPrediction, setMlpPrediction] = useState(null);
                const [gruPrediction, setGruPrediction] = useState(null);
                const [modelTraining, setModelTraining] = useState(false);
                const [analysisReady, setAnalysisReady] = useState(false);

                // Refs
                const continueTradingRef = useRef(false);
                const wsRef = useRef(null);
                const tickWsRef = useRef(null);
                const ticksDataRef = useRef([]);
                const digitsDataRef = useRef([]);
                const signalTimeoutRef = useRef(null);
                const currentSignalRef = useRef('');
                const mlpModelRef = useRef(null);
                const gruModelRef = useRef(null);
                const trainingDataRef = useRef([]);
                const analysisCountRef = useRef(0);

                // Extract last digit based on market type
                const extractLastDigit = (quote, symbol) => {
                    if (symbol === 'RDBEAR' || symbol === 'RDBULL' || symbol === 'R_50' || symbol === 'R_75') {
                        return Math.floor((quote * 10000) % 10);
                    } else if (symbol === 'R_10' || symbol === 'R_25') {
                        return Math.floor((quote * 1000) % 10);
                    } else {
                        return Math.floor((quote * 100) % 10);
                    }
                };

                // Normalize digits to 0-1 range for neural network
                const normalizeDigit = digit => digit / 9.0;

                // Create MLP (Multi-Layer Perceptron) model
                const createMLPModel = () => {
                    if (typeof tf === 'undefined') return null;

                    const model = tf.sequential();
                    // Input layer: 30 features (last 30 digits)
                    model.add(
                        tf.layers.dense({
                            inputShape: [30],
                            units: 64,
                            activation: 'relu',
                            kernelInitializer: 'heNormal',
                        })
                    );
                    model.add(tf.layers.dropout({ rate: 0.2 }));
                    model.add(
                        tf.layers.dense({
                            units: 32,
                            activation: 'relu',
                        })
                    );
                    model.add(tf.layers.dropout({ rate: 0.2 }));
                    // Output layer: 10 classes (digits 0-9)
                    model.add(
                        tf.layers.dense({
                            units: 10,
                            activation: 'softmax',
                        })
                    );

                    model.compile({
                        optimizer: tf.train.adam(0.001),
                        loss: 'categoricalCrossentropy',
                        metrics: ['accuracy'],
                    });

                    return model;
                };

                // Create GRU (Gated Recurrent Unit) model
                const createGRUModel = () => {
                    if (typeof tf === 'undefined') return null;

                    const model = tf.sequential();
                    // Input layer: sequences of 30 timesteps, 1 feature per timestep
                    model.add(
                        tf.layers.gru({
                            inputShape: [30, 1],
                            units: 50,
                            returnSequences: false,
                            activation: 'tanh',
                        })
                    );
                    model.add(tf.layers.dropout({ rate: 0.2 }));
                    model.add(
                        tf.layers.dense({
                            units: 25,
                            activation: 'relu',
                        })
                    );
                    // Output layer: 10 classes (digits 0-9)
                    model.add(
                        tf.layers.dense({
                            units: 10,
                            activation: 'softmax',
                        })
                    );

                    model.compile({
                        optimizer: tf.train.adam(0.001),
                        loss: 'categoricalCrossentropy',
                        metrics: ['accuracy'],
                    });

                    return model;
                };

                // Prepare training data from digit sequences
                const prepareTrainingData = (digits, sequenceLength = 30) => {
                    if (digits.length < sequenceLength + 1) return { X: [], y: [] };

                    const X = [];
                    const y = [];

                    for (let i = sequenceLength; i < digits.length; i++) {
                        const sequence = digits.slice(i - sequenceLength, i);
                        const target = digits[i];

                        // Normalize sequence
                        const normalizedSeq = sequence.map(normalizeDigit);
                        X.push(normalizedSeq);

                        // One-hot encode target
                        const oneHot = Array(10).fill(0);
                        oneHot[target] = 1;
                        y.push(oneHot);
                    }

                    return { X, y };
                };

                // Train MLP model
                const trainMLPModel = async (model, digits) => {
                    if (!model || digits.length < 100) return;

                    const { X, y } = prepareTrainingData(digits, 30);
                    if (X.length === 0) return;

                    const xs = tf.tensor2d(X);
                    const ys = tf.tensor2d(y);

                    try {
                        await model.fit(xs, ys, {
                            epochs: 20,
                            batchSize: 32,
                            validationSplit: 0.2,
                            verbose: 0,
                            callbacks: {
                                onEpochEnd: (epoch, logs) => {
                                    if (epoch % 5 === 0) {
                                    }
                                },
                            },
                        });

                        xs.dispose();
                        ys.dispose();
                    } catch (error) {
                        console.error('MLP training error:', error);
                        xs.dispose();
                        ys.dispose();
                    }
                };

                // Train GRU model
                const trainGRUModel = async (model, digits) => {
                    if (!model || digits.length < 100) return;

                    const { X, y } = prepareTrainingData(digits, 30);
                    if (X.length === 0) return;

                    // Reshape for GRU: [samples, timesteps, features]
                    const XReshaped = X.map(seq => seq.map(val => [val]));

                    const xs = tf.tensor3d(XReshaped);
                    const ys = tf.tensor2d(y);

                    try {
                        await model.fit(xs, ys, {
                            epochs: 20,
                            batchSize: 32,
                            validationSplit: 0.2,
                            verbose: 0,
                            callbacks: {
                                onEpochEnd: (epoch, logs) => {
                                    if (epoch % 5 === 0) {
                                    }
                                },
                            },
                        });

                        xs.dispose();
                        ys.dispose();
                    } catch (error) {
                        console.error('GRU training error:', error);
                        xs.dispose();
                        ys.dispose();
                    }
                };

                // Predict next digit using MLP
                const predictMLP = (model, digits) => {
                    if (!model || digits.length < 30) return null;

                    try {
                        const sequence = digits.slice(-30).map(normalizeDigit);
                        const input = tf.tensor2d([sequence]);
                        const prediction = model.predict(input);
                        const probabilities = prediction.dataSync();
                        prediction.dispose();
                        input.dispose();

                        // Get predicted digit (highest probability)
                        let maxProb = 0;
                        let predictedDigit = 0;
                        for (let i = 0; i < 10; i++) {
                            if (probabilities[i] > maxProb) {
                                maxProb = probabilities[i];
                                predictedDigit = i;
                            }
                        }

                        return { digit: predictedDigit, confidence: maxProb, probabilities };
                    } catch (error) {
                        console.error('MLP prediction error:', error);
                        return null;
                    }
                };

                // Predict next digit using GRU
                const predictGRU = (model, digits) => {
                    if (!model || digits.length < 30) return null;

                    try {
                        const sequence = digits.slice(-30).map(normalizeDigit);
                        const sequenceReshaped = sequence.map(val => [val]);
                        const input = tf.tensor3d([sequenceReshaped]);
                        const prediction = model.predict(input);
                        const probabilities = prediction.dataSync();
                        prediction.dispose();
                        input.dispose();

                        // Get predicted digit (highest probability)
                        let maxProb = 0;
                        let predictedDigit = 0;
                        for (let i = 0; i < 10; i++) {
                            if (probabilities[i] > maxProb) {
                                maxProb = probabilities[i];
                                predictedDigit = i;
                            }
                        }

                        return { digit: predictedDigit, confidence: maxProb, probabilities };
                    } catch (error) {
                        console.error('GRU prediction error:', error);
                        return null;
                    }
                };

                // Initialize and train neural networks
                const updateNeuralNetworks = async () => {
                    if (typeof tf === 'undefined') {
                        return;
                    }

                    const digits = digitsDataRef.current;
                    if (digits.length < 100) return;

                    // Initialize models if not created
                    if (!mlpModelRef.current) {
                        setModelTraining(true);
                        const mlp = createMLPModel();
                        const gru = createGRUModel();
                        mlpModelRef.current = mlp;
                        gruModelRef.current = gru;
                        setMlpModel(mlp);
                        setGruModel(gru);

                        // Train models
                        if (mlp) {
                            await trainMLPModel(mlp, digits);
                        }
                        if (gru) {
                            await trainGRUModel(gru, digits);
                        }
                        setModelTraining(false);
                    } else {
                        // Retrain periodically with new data (every 50 new digits)
                        if (digits.length % 50 === 0 && digits.length > trainingDataRef.current.length) {
                            setModelTraining(true);
                            await trainMLPModel(mlpModelRef.current, digits);
                            await trainGRUModel(gruModelRef.current, digits);
                            trainingDataRef.current = [...digits];
                            setModelTraining(false);
                        }
                    }

                    // Make predictions
                    if (mlpModelRef.current && digits.length >= 30) {
                        const mlpPred = predictMLP(mlpModelRef.current, digits);
                        setMlpPrediction(mlpPred);
                    }

                    if (gruModelRef.current && digits.length >= 30) {
                        const gruPred = predictGRU(gruModelRef.current, digits);
                        setGruPrediction(gruPred);
                    }
                };

                // Calculate percentages from ticks - must be defined before useEffect
                const calculatePercentages = () => {
                    const digits = digitsDataRef.current;
                    const ticks = ticksDataRef.current;

                    if (digits.length < 10 || ticks.length < 2) {
                        setPercentages({});
                        return;
                    }

                    // Use last 60 digits for analysis (as per original)
                    const analysisDigits = digits.slice(-60);
                    const analysisTicks = ticks.slice(-60);
                    const total = analysisDigits.length;

                    if (total === 0) {
                        setPercentages({});
                        return;
                    }

                    const stats = {
                        over: 0,
                        under: 0,
                        even: 0,
                        odd: 0,
                        rise: 0,
                        fall: 0,
                    };

                    const pred = parseInt(prediction) || 5;

                    // Calculate even/odd
                    analysisDigits.forEach(d => {
                        if (d % 2 === 0) stats.even++;
                        else stats.odd++;
                    });

                    // Calculate over/under (using prediction digit)
                    analysisDigits.forEach(d => {
                        if (d > pred) stats.over++;
                        else if (d < pred) stats.under++;
                    });

                    // Calculate rise/fall
                    for (let i = 1; i < analysisTicks.length; i++) {
                        if (analysisTicks[i] > analysisTicks[i - 1]) stats.rise++;
                        else if (analysisTicks[i] < analysisTicks[i - 1]) stats.fall++;
                    }

                    // Convert to percentages
                    const newPercentages = {
                        OVER: stats.over / total,
                        UNDER: stats.under / total,
                        EVEN: stats.even / total,
                        ODD: stats.odd / total,
                        RISE: analysisTicks.length > 1 ? stats.rise / (analysisTicks.length - 1) : 0,
                        FALL: analysisTicks.length > 1 ? stats.fall / (analysisTicks.length - 1) : 0,
                    };

                    setPercentages(newPercentages);
                };

                // WebSocket for price updates - fetch history first, then subscribe
                useEffect(() => {
                    if (!volatility) return;

                    const ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=70505');
                    tickWsRef.current = ws;
                    setLoading(true);

                    ws.onopen = () => {
                        // First, get historical ticks
                        ws.send(
                            JSON.stringify({
                                ticks_history: volatility,
                                count: parseInt(tickCount) || 100,
                                end: 'latest',
                                style: 'ticks',
                            })
                        );
                    };

                    ws.onmessage = e => {
                        const data = JSON.parse(e.data);

                        // Handle historical data
                        if (data.msg_type === 'history' && data.history && data.history.prices) {
                            const prices = data.history.prices.map(p => parseFloat(p));
                            const digits = prices.map(p => extractLastDigit(p, volatility));

                            ticksDataRef.current = prices;
                            digitsDataRef.current = digits;

                            // Update display
                            setLastDigits(digits.slice(-20));
                            if (prices.length > 0) {
                                setPrice(prices[prices.length - 1]);
                            }

                            // Calculate percentages
                            calculatePercentages();

                            // Train and update MLP/GRU models if enough data
                            if (digits.length >= 100) {
                                updateNeuralNetworks().catch(err => {
                                    console.error('Neural network training error:', err);
                                });
                            }

                            setLoading(false);

                            // Now subscribe to live ticks
                            ws.send(
                                JSON.stringify({
                                    ticks: volatility,
                                    subscribe: 1,
                                })
                            );
                        }

                        // Handle live tick updates
                        if (data.msg_type === 'tick' && data.tick) {
                            const quote = parseFloat(data.tick.quote);
                            const lastDigit = extractLastDigit(quote, volatility);

                            setPrice(quote);

                            // Update data arrays
                            ticksDataRef.current = [...ticksDataRef.current, quote].slice(-tickCount);
                            digitsDataRef.current = [...digitsDataRef.current, lastDigit].slice(-tickCount);

                            // Update display
                            setLastDigits(digitsDataRef.current.slice(-20));

                            // Recalculate percentages
                            calculatePercentages();

                            // Train and update MLP/GRU models when enough data
                            if (digitsDataRef.current.length >= 100 && digitsDataRef.current.length % 50 === 0) {
                                updateNeuralNetworks().catch(err => {
                                    console.error('Neural network update error:', err);
                                });
                            }
                        }
                    };

                    ws.onerror = error => {
                        console.error('WebSocket Error:', error);
                        setLoading(false);
                    };

                    ws.onclose = () => {
                        setLoading(false);
                    };

                    return () => {
                        if (ws.readyState === WebSocket.OPEN) {
                            ws.close();
                        }
                    };
                }, [volatility, tickCount, prediction]);

                // Signal detection - only when scanning is ON (runs on interval, not every render)
                useEffect(() => {
                    // Clear signal if scanning is off
                    if (!scanning) {
                        if (currentSignalRef.current !== '') {
                            currentSignalRef.current = '';
                            setSignal('');
                            setHasSignal(false);
                            setCountdown(0);
                            if (signalTimeoutRef.current) {
                                clearTimeout(signalTimeoutRef.current);
                                signalTimeoutRef.current = null;
                            }
                        }
                        // Reset analysis counter
                        analysisCountRef.current = 0;
                        setAnalysisReady(false);
                        return;
                    }

                    // Check signal every 3 seconds when scanning (slower for better analysis)
                    const checkSignal = () => {
                        try {
                            // Need at least 100 digits for proper MLP/GRU analysis
                            if (digitsDataRef.current.length < 100) {
                                setAnalysisReady(false);
                                return;
                            }

                            // Increment analysis count - need multiple analyses before showing signal
                            analysisCountRef.current += 1;

                            // Require at least 5 analysis cycles (15 seconds) before showing signals
                            if (analysisCountRef.current < 5) {
                                setAnalysisReady(false);
                                return;
                            }

                            setAnalysisReady(true);

                            const digits = digitsDataRef.current.slice(-60);
                            const lastDigit = digits[digits.length - 1];
                            const lastTwoDigits = parseInt(digits.slice(-2).join('')) || 0;
                            const pred = parseInt(prediction) || 5;

                            // Get current percentages
                            const currentPercentages = percentages;

                            // Only check if percentages are calculated and valid
                            if (!currentPercentages || Object.keys(currentPercentages).length === 0) {
                                return;
                            }

                            // Validate percentages are numbers
                            const RISE = currentPercentages.RISE || 0;
                            const FALL = currentPercentages.FALL || 0;
                            const EVEN = currentPercentages.EVEN || 0;
                            const ODD = currentPercentages.ODD || 0;
                            const OVER = currentPercentages.OVER || 0;
                            const UNDER = currentPercentages.UNDER || 0;

                            // Check for NaN or invalid values
                            if (
                                isNaN(RISE) ||
                                isNaN(FALL) ||
                                isNaN(EVEN) ||
                                isNaN(ODD) ||
                                isNaN(OVER) ||
                                isNaN(UNDER)
                            ) {
                                return;
                            }

                            // Get MLP and GRU predictions
                            const mlpPred = mlpPrediction;
                            const gruPred = gruPrediction;

                            let detectedSignal = '';
                            let conditionMet = false;
                            let mlpAgreement = false;
                            let gruAgreement = false;

                            // RISE (CALL) - threshold 0.45 (45%) + MLP/GRU confirmation
                            if (contractType === 'CALL') {
                                conditionMet = RISE > 0.45;
                                // Check MLP/GRU agreement for RISE (higher digits = rise)
                                if (mlpPred && mlpPred.probabilities) {
                                    const mlpNextRise =
                                        mlpPred.probabilities.slice(5, 10).reduce((a, b) => a + b, 0) > 0.5;
                                    mlpAgreement = mlpNextRise;
                                }
                                if (gruPred && gruPred.probabilities) {
                                    const gruNextRise =
                                        gruPred.probabilities.slice(5, 10).reduce((a, b) => a + b, 0) > 0.5;
                                    gruAgreement = gruNextRise;
                                }
                                if (conditionMet && (mlpAgreement || gruAgreement || (!mlpPred && !gruPred))) {
                                    const aiConf =
                                        mlpAgreement && gruAgreement
                                            ? ' (AI: Strong)'
                                            : mlpAgreement || gruAgreement
                                              ? ' (AI: Moderate)'
                                              : '';
                                    detectedSignal = `Signal: RISE — ${(RISE * 100).toFixed(0)}%${aiConf}`;
                                }
                            }
                            // FALL (PUT) - threshold 0.45 (45%) + MLP/GRU confirmation
                            else if (contractType === 'PUT') {
                                conditionMet = FALL > 0.45;
                                // Check MLP/GRU agreement for FALL (lower digits = fall)
                                if (mlpPred && mlpPred.probabilities) {
                                    const mlpNextFall =
                                        mlpPred.probabilities.slice(0, 5).reduce((a, b) => a + b, 0) > 0.5;
                                    mlpAgreement = mlpNextFall;
                                }
                                if (gruPred && gruPred.probabilities) {
                                    const gruNextFall =
                                        gruPred.probabilities.slice(0, 5).reduce((a, b) => a + b, 0) > 0.5;
                                    gruAgreement = gruNextFall;
                                }
                                if (conditionMet && (mlpAgreement || gruAgreement || (!mlpPred && !gruPred))) {
                                    const aiConf =
                                        mlpAgreement && gruAgreement
                                            ? ' (AI: Strong)'
                                            : mlpAgreement || gruAgreement
                                              ? ' (AI: Moderate)'
                                              : '';
                                    detectedSignal = `Signal: FALL — ${(FALL * 100).toFixed(0)}%${aiConf}`;
                                }
                            }
                            // EVEN - threshold 0.53 (53%) AND current digit must be ODD + MLP/GRU
                            else if (contractType === 'EVEN') {
                                conditionMet = EVEN > 0.53 && lastDigit % 2 !== 0;
                                // Check if MLP/GRU predict even digit
                                if (mlpPred && mlpPred.probabilities) {
                                    const mlpEvenProb = [0, 2, 4, 6, 8].reduce(
                                        (sum, d) => sum + (mlpPred.probabilities[d] || 0),
                                        0
                                    );
                                    mlpAgreement = mlpEvenProb > 0.5;
                                }
                                if (gruPred && gruPred.probabilities) {
                                    const gruEvenProb = [0, 2, 4, 6, 8].reduce(
                                        (sum, d) => sum + (gruPred.probabilities[d] || 0),
                                        0
                                    );
                                    gruAgreement = gruEvenProb > 0.5;
                                }
                                if (conditionMet && (mlpAgreement || gruAgreement || (!mlpPred && !gruPred))) {
                                    const aiConf =
                                        mlpAgreement && gruAgreement
                                            ? ' (AI: Strong)'
                                            : mlpAgreement || gruAgreement
                                              ? ' (AI: Moderate)'
                                              : '';
                                    detectedSignal = `Signal: EVEN — ${(EVEN * 100).toFixed(0)}%${aiConf}`;
                                }
                            }
                            // ODD - threshold 0.53 (53%) AND current digit must be EVEN + MLP/GRU
                            else if (contractType === 'ODD') {
                                conditionMet = ODD > 0.53 && lastDigit % 2 === 0;
                                // Check if MLP/GRU predict odd digit
                                if (mlpPred && mlpPred.probabilities) {
                                    const mlpOddProb = [1, 3, 5, 7, 9].reduce(
                                        (sum, d) => sum + (mlpPred.probabilities[d] || 0),
                                        0
                                    );
                                    mlpAgreement = mlpOddProb > 0.5;
                                }
                                if (gruPred && gruPred.probabilities) {
                                    const gruOddProb = [1, 3, 5, 7, 9].reduce(
                                        (sum, d) => sum + (gruPred.probabilities[d] || 0),
                                        0
                                    );
                                    gruAgreement = gruOddProb > 0.5;
                                }
                                if (conditionMet && (mlpAgreement || gruAgreement || (!mlpPred && !gruPred))) {
                                    const aiConf =
                                        mlpAgreement && gruAgreement
                                            ? ' (AI: Strong)'
                                            : mlpAgreement || gruAgreement
                                              ? ' (AI: Moderate)'
                                              : '';
                                    detectedSignal = `Signal: ODD — ${(ODD * 100).toFixed(0)}%${aiConf}`;
                                }
                            }
                            // OVER - threshold 0.53 (53%) AND last 2 digits combined < 5 + MLP/GRU
                            else if (contractType === 'OVER') {
                                conditionMet = OVER > 0.53 && lastTwoDigits < 5;
                                // Check if MLP/GRU predict digit > prediction
                                if (mlpPred && mlpPred.probabilities) {
                                    const mlpOverProb = Array.from({ length: 10 }, (_, i) => i)
                                        .filter(d => d > pred)
                                        .reduce((sum, d) => sum + (mlpPred.probabilities[d] || 0), 0);
                                    mlpAgreement = mlpOverProb > 0.5;
                                }
                                if (gruPred && gruPred.probabilities) {
                                    const gruOverProb = Array.from({ length: 10 }, (_, i) => i)
                                        .filter(d => d > pred)
                                        .reduce((sum, d) => sum + (gruPred.probabilities[d] || 0), 0);
                                    gruAgreement = gruOverProb > 0.5;
                                }
                                if (conditionMet && (mlpAgreement || gruAgreement || (!mlpPred && !gruPred))) {
                                    const aiConf =
                                        mlpAgreement && gruAgreement
                                            ? ' (AI: Strong)'
                                            : mlpAgreement || gruAgreement
                                              ? ' (AI: Moderate)'
                                              : '';
                                    detectedSignal = `Signal: OVER — ${lastTwoDigits} > ${pred}${aiConf}`;
                                }
                            }
                            // UNDER - threshold 0.53 (53%) AND last 2 digits combined > 4 + MLP/GRU
                            else if (contractType === 'UNDER') {
                                conditionMet = UNDER > 0.53 && lastTwoDigits > 4;
                                // Check if MLP/GRU predict digit < prediction
                                if (mlpPred && mlpPred.probabilities) {
                                    const mlpUnderProb = Array.from({ length: 10 }, (_, i) => i)
                                        .filter(d => d < pred)
                                        .reduce((sum, d) => sum + (mlpPred.probabilities[d] || 0), 0);
                                    mlpAgreement = mlpUnderProb > 0.5;
                                }
                                if (gruPred && gruPred.probabilities) {
                                    const gruUnderProb = Array.from({ length: 10 }, (_, i) => i)
                                        .filter(d => d < pred)
                                        .reduce((sum, d) => sum + (gruPred.probabilities[d] || 0), 0);
                                    gruAgreement = gruUnderProb > 0.5;
                                }
                                if (conditionMet && (mlpAgreement || gruAgreement || (!mlpPred && !gruPred))) {
                                    const aiConf =
                                        mlpAgreement && gruAgreement
                                            ? ' (AI: Strong)'
                                            : mlpAgreement || gruAgreement
                                              ? ' (AI: Moderate)'
                                              : '';
                                    detectedSignal = `Signal: UNDER — ${lastTwoDigits} < ${pred}${aiConf}`;
                                }
                            }
                            // MATCHES - check if prediction is among 3 least frequent digits + MLP/GRU
                            else if (contractType === 'MATCHES' && prediction !== '') {
                                const digitCounts = Array(10).fill(0);
                                digits.forEach(d => digitCounts[d]++);
                                const frequencies = digitCounts.map((count, idx) => ({
                                    digit: idx,
                                    count: count / digits.length,
                                }));
                                frequencies.sort((a, b) => a.count - b.count);
                                const leastFrequent = frequencies.slice(0, 3).map(f => f.digit);

                                conditionMet = leastFrequent.includes(pred);
                                // Check if MLP/GRU also predict this digit
                                if (mlpPred) {
                                    mlpAgreement = mlpPred.digit === pred && mlpPred.confidence > 0.3;
                                }
                                if (gruPred) {
                                    gruAgreement = gruPred.digit === pred && gruPred.confidence > 0.3;
                                }
                                if (conditionMet && (mlpAgreement || gruAgreement || (!mlpPred && !gruPred))) {
                                    const aiConf =
                                        mlpAgreement && gruAgreement
                                            ? ' (AI: Strong)'
                                            : mlpAgreement || gruAgreement
                                              ? ' (AI: Moderate)'
                                              : '';
                                    detectedSignal = `Signal: MATCHES — ${pred} among 3 least frequent${aiConf}`;
                                }
                            }
                            // DIFFERS - check if prediction is among 3 most frequent digits + MLP/GRU
                            else if (contractType === 'DIFFERS' && prediction !== '') {
                                const digitCounts = Array(10).fill(0);
                                digits.forEach(d => digitCounts[d]++);
                                const frequencies = digitCounts.map((count, idx) => ({
                                    digit: idx,
                                    count: count / digits.length,
                                }));
                                frequencies.sort((a, b) => b.count - a.count);
                                const mostFrequent = frequencies.slice(0, 3).map(f => f.digit);

                                conditionMet = mostFrequent.includes(pred);
                                // Check if MLP/GRU predict different digit
                                if (mlpPred) {
                                    mlpAgreement = mlpPred.digit !== pred && mlpPred.confidence > 0.3;
                                }
                                if (gruPred) {
                                    gruAgreement = gruPred.digit !== pred && gruPred.confidence > 0.3;
                                }
                                if (conditionMet && (mlpAgreement || gruAgreement || (!mlpPred && !gruPred))) {
                                    const aiConf =
                                        mlpAgreement && gruAgreement
                                            ? ' (AI: Strong)'
                                            : mlpAgreement || gruAgreement
                                              ? ' (AI: Moderate)'
                                              : '';
                                    detectedSignal = `Signal: DIFFERS — ${pred} among 3 most frequent${aiConf}`;
                                }
                            }

                            // Only update signal if condition is actually met
                            if (conditionMet && detectedSignal) {
                                // Only set if different from current signal
                                if (currentSignalRef.current !== detectedSignal) {
                                    currentSignalRef.current = detectedSignal;
                                    setSignal(detectedSignal);
                                    setHasSignal(true);
                                    setCountdown(50);

                                    // Clear existing timeout
                                    if (signalTimeoutRef.current) {
                                        clearTimeout(signalTimeoutRef.current);
                                    }

                                    // Auto-clear signal after 50 seconds
                                    signalTimeoutRef.current = setTimeout(() => {
                                        currentSignalRef.current = '';
                                        setSignal('');
                                        setHasSignal(false);
                                        setCountdown(0);
                                        signalTimeoutRef.current = null;
                                    }, 50000);

                                    // Note: Auto-trading is handled in contract completion, not here
                                }
                            } else {
                                // Clear signal if conditions no longer met
                                if (currentSignalRef.current !== '') {
                                    currentSignalRef.current = '';
                                    setSignal('');
                                    setHasSignal(false);
                                    setCountdown(0);
                                    if (signalTimeoutRef.current) {
                                        clearTimeout(signalTimeoutRef.current);
                                        signalTimeoutRef.current = null;
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Error in signal detection:', error);
                            // Don't crash the component, just log the error
                        }
                    };

                    // Run check immediately
                    checkSignal();

                    // Then check every 3 seconds (slower for better analysis)
                    const interval = setInterval(checkSignal, 3000);

                    return () => {
                        clearInterval(interval);
                    };
                }, [scanning, contractType, prediction]); // Removed percentages, mlpPrediction, gruPrediction to prevent infinite loops

                // Countdown timer
                useEffect(() => {
                    if (countdown > 0) {
                        const timer = setInterval(() => {
                            setCountdown(prev => Math.max(0, prev - 1));
                        }, 1000);
                        return () => clearInterval(timer);
                    }
                }, [countdown]);

                const sendProposal = ws => {
                    const pred = ['OVER', 'UNDER', 'MATCHES', 'DIFFERS'].includes(contractType)
                        ? parseInt(prediction)
                        : undefined;

                    const contractMap = {
                        CALL: 'CALL',
                        PUT: 'PUT',
                        EVEN: 'DIGITEVEN',
                        ODD: 'DIGITODD',
                        OVER: 'DIGITOVER',
                        UNDER: 'DIGITUNDER',
                        MATCHES: 'DIGITMATCH',
                        DIFFERS: 'DIGITDIFF',
                    };

                    ws.send(
                        JSON.stringify({
                            proposal: 1,
                            amount: parseFloat(stake),
                            basis: 'stake',
                            contract_type: contractMap[contractType],
                            currency: 'USD',
                            symbol: volatility,
                            duration: parseInt(duration),
                            duration_unit: 't',
                            ...(pred !== undefined ? { barrier: pred } : {}),
                        })
                    );
                };

                // Run bot handler - original signal-based trading
                const handleRunBot = async () => {
                    const token = localStorage.getItem('authToken');
                    if (!token) {
                        alert('Login Required! Please login to your account first.');
                        return;
                    }

                    if (running) {
                        // Stop trading
                        continueTradingRef.current = false;
                        setRunning(false);
                        if (wsRef.current) {
                            wsRef.current.close();
                            wsRef.current = null;
                        }
                        return;
                    }

                    // Check if we have a signal (only for first trade)
                    if (!hasSignal) {
                        alert("No signal detected! Please wait for a signal or use 'SCAN ENTRY' first.");
                        return;
                    }

                    // Start trading
                    continueTradingRef.current = true;
                    setRunning(true);

                    const ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=70505');
                    wsRef.current = ws;
                    let isAuthorized = false;
                    let baseStakeValue = parseFloat(stake);
                    let currentStep = 0;

                    ws.onopen = () => {
                        ws.send(JSON.stringify({ authorize: token }));
                    };

                    ws.onmessage = e => {
                        try {
                            const data = JSON.parse(e.data);

                            // Handle errors
                            if (data.error) {
                                console.error('WebSocket error:', data.error);
                                alert('Error: ' + (data.error.message || JSON.stringify(data.error)));
                                return;
                            }

                            if (data.msg_type === 'authorize') {
                                isAuthorized = true;
                                // Send proposal for first trade (signal already checked before starting)
                                sendProposal(ws);
                            } else if (data.msg_type === 'proposal') {
                                if (data.proposal) {
                                    // Buy when proposal is received
                                    ws.send(
                                        JSON.stringify({
                                            buy: data.proposal.id,
                                            price: data.proposal.ask_price,
                                        })
                                    );
                                } else if (data.error) {
                                    console.error('Proposal error:', data.error);
                                    alert('Proposal error: ' + (data.error.message || JSON.stringify(data.error)));
                                    // Try next trade if continue trading
                                    if (continueTradingRef.current) {
                                        setTimeout(() => {
                                            if (continueTradingRef.current && ws.readyState === WebSocket.OPEN) {
                                                sendProposal(ws);
                                            }
                                        }, 2000);
                                    }
                                }
                            } else if (data.msg_type === 'buy') {
                                if (data.buy && data.buy.contract_id) {
                                    const contract = data.buy;
                                    const contractId = contract.contract_id;

                                    console.log('Buy successful, contract ID:', contractId);

                                    // Add transaction
                                    setTransactions(prev => {
                                        const newTransaction = {
                                            id: Date.now() + Math.random(), // Unique ID
                                            contract_type: contractType,
                                            entry_spot:
                                                contract.entry_tick_display_value ||
                                                contract.entry_spot_display_value ||
                                                contract.entry_tick ||
                                                '-',
                                            exit_spot: '-',
                                            stake: parseFloat(stake).toFixed(2),
                                            profit: '0.00',
                                            status: '⏳',
                                            contract_id: contractId,
                                        };
                                        console.log('Adding transaction:', newTransaction);
                                        return [newTransaction, ...prev];
                                    });

                                    // Clear signal after placing trade (will wait for next signal if continueTradingRef is true)
                                    setSignal('');
                                    setHasSignal(false);
                                    setCountdown(0);

                                    // Subscribe to contract updates
                                    ws.send(
                                        JSON.stringify({
                                            proposal_open_contract: 1,
                                            contract_id: contractId,
                                            subscribe: 1,
                                        })
                                    );
                                } else if (data.error) {
                                    console.error('Buy error:', data.error);
                                    alert('Buy error: ' + (data.error.message || JSON.stringify(data.error)));
                                    // Try next trade if continue trading
                                    if (continueTradingRef.current) {
                                        setTimeout(() => {
                                            if (continueTradingRef.current && ws.readyState === WebSocket.OPEN) {
                                                sendProposal(ws);
                                            }
                                        }, 2000);
                                    }
                                }
                            } else if (data.msg_type === 'proposal_open_contract') {
                                const contract = data.proposal_open_contract;
                                const contractId = contract.contract_id;

                                // Update entry spot (check both display_value and tick_display_value)
                                const entrySpot =
                                    contract.entry_spot_display_value ||
                                    contract.entry_tick_display_value ||
                                    contract.entry_tick ||
                                    '-';
                                const currentProfit = parseFloat(contract.profit || 0);

                                // Always update entry spot and live profit
                                setTransactions(prev =>
                                    prev.map(t => {
                                        if (t.contract_id === contractId) {
                                            const updated = { ...t };

                                            // Update entry spot if available
                                            if (entrySpot !== '-') {
                                                updated.entry_spot = entrySpot;
                                            }

                                            // Update live profit/loss (even if contract not sold yet)
                                            updated.profit = currentProfit.toFixed(2);

                                            // Update exit spot if contract is sold
                                            if (contract.is_sold) {
                                                updated.exit_spot =
                                                    contract.exit_spot_display_value ||
                                                    contract.exit_tick_display_value ||
                                                    contract.exit_tick ||
                                                    '-';
                                                updated.status = currentProfit > 0 ? 'WIN ✅' : 'LOSS ❌';
                                            } else {
                                                // Contract still open - show live status
                                                updated.status =
                                                    currentProfit > 0 ? '🟢' : currentProfit < 0 ? '🔴' : '⏳';
                                            }

                                            return updated;
                                        }
                                        return t;
                                    })
                                );

                                // Handle closed contracts
                                if (contract.is_sold) {
                                    const profit = currentProfit;
                                    const isWin = profit > 0;

                                    setRuns(prev => prev + 1);
                                    if (isWin) setWon(prev => prev + 1);
                                    else setLost(prev => prev + 1);

                                    setTotalProfit(prev => {
                                        const newTotal = prev + profit;

                                        // Check target/stop loss
                                        if (newTotal >= parseFloat(targetProfit)) {
                                            alert('CONGRATULATIONS! Target Profit hit!');
                                            continueTradingRef.current = false;
                                            setRunning(false);
                                            ws.close();
                                            return newTotal;
                                        }
                                        if (newTotal <= -parseFloat(stopLoss)) {
                                            alert('STOP LOSS HIT!');
                                            continueTradingRef.current = false;
                                            setRunning(false);
                                            ws.close();
                                            return newTotal;
                                        }

                                        return newTotal;
                                    });

                                    // Martingale logic
                                    if (useMartingale) {
                                        if (profit <= 0) {
                                            currentStep = Math.min(currentStep + 1, 50);
                                            const newStake = (
                                                baseStakeValue * Math.pow(parseFloat(martingale), currentStep)
                                            ).toFixed(2);
                                            setStake(newStake);
                                        } else {
                                            currentStep = 0;
                                            setStake(baseStakeValue.toFixed(2));
                                        }
                                    }

                                    // Continue trading if flag is set
                                    if (continueTradingRef.current) {
                                        // Immediately send proposal for next trade (no signal needed)
                                        setTimeout(() => {
                                            if (continueTradingRef.current && ws.readyState === WebSocket.OPEN) {
                                                sendProposal(ws);
                                            }
                                        }, 1000); // Small delay before next trade
                                    } else {
                                        // Stop bot after trade completes
                                        setRunning(false);
                                        ws.close();
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Error processing WebSocket message:', error);
                            console.error('Raw message:', e.data);
                        }
                    };

                    ws.onclose = () => {
                        setRunning(false);
                    };

                    ws.onerror = error => {
                        console.error('WebSocket error:', error);
                        setRunning(false);
                    };
                };

                const handleReset = () => {
                    setTransactions([]);
                    setRuns(0);
                    setWon(0);
                    setLost(0);
                    setTotalProfit(0);
                    setSignal('');
                    setHasSignal(false);
                    setCountdown(0);
                };

                return (
                    <div className='bot-general'>
                        <header className='st-header'>
                            <h1 className='st-title'>TickMaster Tool - v2</h1>
                            {price !== null && (
                                <p className='vol-price'>
                                    Price: <strong>{price.toFixed(2)}</strong>
                                </p>
                            )}
                        </header>

                        <div className='bot-controlz-wrapper'>
                            <div className='bot-controlz'>
                                <label>
                                    Volatility:
                                    <select value={volatility} onChange={e => setVolatility(e.target.value)}>
                                        <option value='1HZ10V'>Volatility 10 (1s)</option>
                                        <option value='R_10'>Volatility 10</option>
                                        <option value='1HZ15V'>Volatility 15 (1s)</option>
                                        <option value='1HZ25V'>Volatility 25 (1s)</option>
                                        <option value='R_25'>Volatility 25</option>
                                        <option value='1HZ30V'>Volatility 30 (1s)</option>
                                        <option value='1HZ50V'>Volatility 50 (1s)</option>
                                        <option value='R_50'>Volatility 50</option>
                                        <option value='1HZ75V'>Volatility 75 (1s)</option>
                                        <option value='R_75'>Volatility 75</option>
                                        <option value='1HZ90V'>Volatility 90 (1s)</option>
                                        <option value='1HZ100V'>Volatility 100 (1s)</option>
                                        <option value='R_100'>Volatility 100</option>
                                    </select>
                                </label>

                                <label>
                                    Contract Type:
                                    <select value={contractType} onChange={e => setContractType(e.target.value)}>
                                        <option value='CALL'>RISE</option>
                                        <option value='PUT'>FALL</option>
                                        <option value='EVEN'>EVEN</option>
                                        <option value='ODD'>ODD</option>
                                        <option value='OVER'>OVER</option>
                                        <option value='UNDER'>UNDER</option>
                                        <option value='MATCHES'>MATCHES</option>
                                        <option value='DIFFERS'>DIFFERS</option>
                                    </select>
                                </label>

                                {['OVER', 'UNDER', 'MATCHES', 'DIFFERS'].includes(contractType) && (
                                    <label>
                                        Prediction:
                                        <input
                                            type='number'
                                            min='0'
                                            max='9'
                                            value={prediction}
                                            onChange={e => setPrediction(e.target.value)}
                                        />
                                    </label>
                                )}

                                <label>
                                    Stake:
                                    <input type='number' value={stake} onChange={e => setStake(e.target.value)} />
                                </label>

                                <label>
                                    Duration (ticks):
                                    <input type='number' value={duration} onChange={e => setDuration(e.target.value)} />
                                </label>

                                <label>
                                    Target Profit:
                                    <input
                                        type='number'
                                        value={targetProfit}
                                        onChange={e => setTargetProfit(e.target.value)}
                                    />
                                </label>

                                <label>
                                    Stop Loss:
                                    <input type='number' value={stopLoss} onChange={e => setStopLoss(e.target.value)} />
                                </label>

                                <div className='martingale-section'>
                                    <label className='toggle-label'>
                                        <input
                                            type='checkbox'
                                            checked={useMartingale}
                                            onChange={e => setUseMartingale(e.target.checked)}
                                        />
                                        <span className='slider'></span>
                                    </label>
                                    <span className='toggle-text'>Use Martingale</span>
                                </div>

                                {useMartingale && (
                                    <div className='martingale-input'>
                                        <label>
                                            Martingale:
                                            <input
                                                type='number'
                                                step='0.1'
                                                min='1'
                                                value={martingale}
                                                onChange={e => setMartingale(e.target.value)}
                                            />
                                        </label>
                                    </div>
                                )}

                                <label>
                                    Ticks to Analyze:
                                    <input
                                        type='number'
                                        min='10'
                                        max='1000'
                                        value={tickCount}
                                        onChange={e => setTickCount(e.target.value)}
                                    />
                                </label>
                            </div>

                            <div className={`signal-display-zone ${hasSignal ? 'signal-found' : ''}`}>
                                {scanning ? (
                                    loading ? (
                                        <div>
                                            <div className='loadingg'>
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                            </div>
                                            <p>Please wait...</p>
                                        </div>
                                    ) : hasSignal ? (
                                        <div>
                                            <h2 className='signal-found-header'>SIGNAL CONFIRMED!</h2>
                                            <p className='blink-text'>
                                                {countdown > 10 ? 'RUN BOT NOW!' : "Don't Run, You are late"}
                                            </p>
                                            <p>{signal}</p>
                                            {(mlpPrediction || gruPrediction) && (
                                                <div
                                                    style={{
                                                        marginTop: '15px',
                                                        padding: '10px',
                                                        background: '#fff',
                                                        borderRadius: '5px',
                                                        fontSize: '14px',
                                                    }}
                                                >
                                                    <strong>AI Predictions:</strong>
                                                    {mlpPrediction && (
                                                        <div style={{ marginTop: '5px' }}>
                                                            MLP: Digit {mlpPrediction.digit} (
                                                            {(mlpPrediction.confidence * 100).toFixed(1)}% confidence)
                                                        </div>
                                                    )}
                                                    {gruPrediction && (
                                                        <div style={{ marginTop: '5px' }}>
                                                            GRU: Digit {gruPrediction.digit} (
                                                            {(gruPrediction.confidence * 100).toFixed(1)}% confidence)
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    ) : (
                                        <div>
                                            <p>Analyzing market data...</p>
                                            {(mlpPrediction || gruPrediction) && (
                                                <div
                                                    style={{
                                                        marginTop: '10px',
                                                        padding: '10px',
                                                        background: '#fff',
                                                        borderRadius: '5px',
                                                        fontSize: '14px',
                                                    }}
                                                >
                                                    <strong>AI Predictions:</strong>
                                                    {mlpPrediction && (
                                                        <div style={{ marginTop: '5px' }}>
                                                            MLP: Digit {mlpPrediction.digit} (
                                                            {(mlpPrediction.confidence * 100).toFixed(1)}% confidence)
                                                        </div>
                                                    )}
                                                    {gruPrediction && (
                                                        <div style={{ marginTop: '5px' }}>
                                                            GRU: Digit {gruPrediction.digit} (
                                                            {(gruPrediction.confidence * 100).toFixed(1)}% confidence)
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    )
                                ) : (
                                    <p>STEPS: Set → Scan Entry → Run</p>
                                )}
                            </div>
                        </div>

                        <div className='action-buttons-container'>
                            <button
                                className={`scan-btnn ${scanning ? 'scanning' : 'stopped'}`}
                                onClick={() => {
                                    setScanning(!scanning);
                                    setLoading(true);
                                    setTimeout(() => setLoading(false), 2000);
                                }}
                            >
                                {scanning ? 'STOP SCAN' : 'SCAN ENTRY'}
                            </button>
                        </div>

                        <div className='main-transactions-section'>
                            {running && <p className='its-running'>BOT IS RUNNING...</p>}

                            {countdown > 0 && (
                                <p className='countdown-msg'>
                                    Your Signal Expires in <span>{countdown}s</span>
                                </p>
                            )}

                            <div className='user-buttons'>
                                <button className={running ? 'my-stop-button' : 'my-run-button'} onClick={handleRunBot}>
                                    {running ? '⏹ STOP BOT' : '▶ RUN BOT'}
                                </button>
                                <button className='data-reset-btn' onClick={handleReset}>
                                    Reset
                                </button>
                            </div>

                            <div className='main-table-contents'>
                                <h3>Transactions</h3>
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Contract Type</th>
                                            <th>Entry/Exit Spot</th>
                                            <th>Stake & P/L</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {transactions.length === 0 ? (
                                            <tr>
                                                <td colSpan='3' className='zero-transactions'>
                                                    No transactions to display
                                                </td>
                                            </tr>
                                        ) : (
                                            transactions.map(t => (
                                                <tr key={t.id}>
                                                    <td>{t.contract_type}</td>
                                                    <td>
                                                        <div>
                                                            <span>Entry: {t.entry_spot}</span>
                                                            <br />
                                                            <span>
                                                                Exit: {t.exit_spot === '-' ? 'Open' : t.exit_spot}
                                                            </span>
                                                        </div>
                                                    </td>
                                                    <td>
                                                        <div>
                                                            <span>Stake: {t.stake} USD</span>
                                                            <br />
                                                            <span
                                                                className={
                                                                    t.profit === '-'
                                                                        ? ''
                                                                        : parseFloat(t.profit) >= 0
                                                                          ? 'profit-win'
                                                                          : 'profit-loss'
                                                                }
                                                            >
                                                                {t.profit === '-'
                                                                    ? '- USD'
                                                                    : parseFloat(t.profit) >= 0
                                                                      ? `+${t.profit}`
                                                                      : t.profit}{' '}
                                                                USD
                                                            </span>
                                                        </div>
                                                    </td>
                                                </tr>
                                            ))
                                        )}
                                    </tbody>
                                </table>
                            </div>

                            <div className='trades-summary'>
                                <div className='summary-item'>
                                    <h3>No. of runs</h3>
                                    <p>{runs}</p>
                                </div>
                                <div className='summary-item'>
                                    <h3>Contracts won</h3>
                                    <p>{won}</p>
                                </div>
                                <div className='summary-item'>
                                    <h3>Contracts lost</h3>
                                    <p>{lost}</p>
                                </div>
                                <div className='summary-item'>
                                    <h3>Total profit/loss</h3>
                                    <p className={`display ${totalProfit >= 0 ? 'profit-won' : 'profit-lost'}`}>
                                        {totalProfit.toFixed(2)}
                                    </p>
                                </div>
                            </div>
                        </div>

                        {running && (
                            <div className='stats-container'>
                                <div className='stats-header'>
                                    <h3 className='section-heading'>Percentages</h3>
                                </div>
                                <div className='stats-wrapper'>
                                    <div className='livestream-section'>
                                        <div className='cumulative-container'>
                                            <p className='section-heading'>Contract Type Percentages</p>
                                            <div className='stats-gridd'>
                                                {Object.entries(percentages)
                                                    .filter(([key]) => key !== 'digits')
                                                    .map(([key, value]) => (
                                                        <div key={key} className='stat-item'>
                                                            <strong>{key}</strong>
                                                            <br />
                                                            <span>{(value * 100).toFixed(0)}%</span>
                                                        </div>
                                                    ))}
                                            </div>
                                        </div>
                                        <h3 className='section-heading'>Last Digits Stream</h3>
                                        <div className='ticks-list'>
                                            {lastDigits
                                                .slice()
                                                .reverse()
                                                .map((digit, idx) => (
                                                    <span
                                                        key={idx}
                                                        className={`tick-item ${idx === 0 ? 'latest' : ''}`}
                                                    >
                                                        {digit}
                                                    </span>
                                                ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // Check for API token in URL parameter
            function checkUrlToken() {
                const urlParams = new URLSearchParams(window.location.search);
                const token = urlParams.get('token') || urlParams.get('api_token') || urlParams.get('api');
                if (token) {
                    localStorage.setItem('authToken', token);
                    // Remove token from URL for security
                    const newUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, newUrl);
                }
            }

            // Wait for all scripts to load before rendering
            function waitForReact() {
                if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
                    setTimeout(waitForReact, 50);
                    return;
                }

                // Check URL for token first
                checkUrlToken();

                try {
                    const rootElement = document.getElementById('root');
                    if (!rootElement) {
                        return;
                    }

                    ReactDOM.render(<TickMasterTool />, rootElement);
                } catch (error) {
                    console.error('Error rendering React app:', error);
                    const rootElement = document.getElementById('root');
                    if (rootElement) {
                        rootElement.innerHTML =
                            '<div style="padding: 20px; color: red; font-size: 16px; background: #fff; border: 2px solid red; border-radius: 5px; margin: 20px;">' +
                            '<h2>Error Rendering Component</h2>' +
                            '<p><strong>Error:</strong> ' +
                            error.toString() +
                            '</p>' +
                            '<p><strong>Message:</strong> ' +
                            (error.message || 'Unknown error') +
                            '</p>' +
                            '<p>Please check the browser console (F12) for more details.</p>' +
                            '</div>';
                    }
                }
            }

            // Start waiting when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', waitForReact);
            } else {
                waitForReact();
            }
        </script>
    </body>
</html>
